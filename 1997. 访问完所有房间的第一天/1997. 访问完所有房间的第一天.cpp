// 规则 1： 加上当天如果是第奇数次访问该房间，那么需要回退到 nextVisit[i] 房间，nextVisit[i] 一定小于等于当前的房间号，也就是说 nextVisit 数组是一个专门回退之前房间的数组
// 规则 2： 加上当天如果是第偶数次访问该房间，那么就可以访问下一个房间，从中我们看出如果想要访问下一个房间，那么只能通过规则2进行访问，因为规则1只能回到之前的房间，并不能跳到后面从未访问过的新房间，也就是说我们每次访问新房间都是从之前访问过的房前的后一个，不会跳跃式的访问没有访问过的房间
// 而且从 nextVisit 回退到的房间不算这一次回退的访问次数一定是偶数次，加上这次回退的是奇数次，假设回退的位置是奇数次，那么之前在访问到该位置时，一定会回退，不可能再去访问后面的新房间，又或者我们知道要访问第一新房间，那么他的前一个房间一定是访问了偶数次，如果回退的位置时奇数次，就不可能访问到后面的从未访问过的新房间

// 定义dp[i]是第一次访问第i个房间所需要的天数，那么第i+1个房间第一次访问到的时间就为 dp[i+1]=dp[i]+1+(dp[i]-d[j])+1;
// 如果第一次访问第 i 个房间,那么他一定是从 i-1个房间访问偶数次后才访问到下一个的
class Solution {
public:
    int firstDayBeenInAllRooms(vector<int>& nextVisit) {
        int m = nextVisit.size();

        vector<long long> dp = vector<long long>(m+1);
        int mod = 1e9+7;

        for(int i=0;i<m;i++)
        {
            int j=nextVisit[i];  //第一次访问到i位置需要回退的房间号
            dp[i+1]=(dp[i]+1+dp[i]-dp[j]+1+mod)%mod;
        }
        return dp[m-1];
    }
};